---
title: "Generics BDA"
output: html_notebook
---


```{r}
library(rwebppl)
library(tidyverse)
library(knitr)
library(coda)
estimate_mode <- function(s) {
  d <- density(s)
  return(d$x[which.max(d$y)])
}
hdi_upper<- function(s){
  m <- HPDinterval(mcmc(s))
  return(m["var1","upper"])
}
hdi_lower<- function(s){
  m <- HPDinterval(mcmc(s))
  return(m["var1","lower"])
}
```

```{r}
readData = function(folder, proj){
  read_csv(
    paste("../data/",folder, proj,"/",
          proj,"-trials.csv", sep = "")
    )
}

readCatchInfo = function(folder, proj){
  read_csv(
    paste("../data/",folder, proj,"/",
          proj,"-catch_trials.csv", sep = "")
    )
}

priorDataLabel = "prior-3"
interpretationDataLabel = "interpretation-6"
```

## Load data
Prior data

```{r}
df.prior <- readData("prior/", priorDataLabel)
df.prior.catch <- readCatchInfo("prior/", priorDataLabel)

df.prior.catch.summary <- df.prior.catch %>%
  group_by(workerid, tested_on) %>%
  summarize(totalCorrect = sum(correct)) %>%
  ungroup() %>%
  spread(tested_on, totalCorrect) %>%
  rename(correct_rejection = `0`, 
         hit = `1`) %>%
  mutate(pass = ifelse(hit >= 4 & correct_rejection >= 4, 1, 0),
         totalCorrect = correct_rejection + hit)

df.prior <- left_join(df.prior, df.prior.catch.summary %>%
                         select(workerid, totalCorrect, pass))

df.prior.filtered <- df.prior %>% 
  filter(pass == 1, trial_type == "prevalence_elicitation") %>%
  mutate(response = as.numeric(response))

```

Interpretation (posterior) data

```{r}
df.int.catch <- readCatchInfo("interpretation/", interpretationDataLabel)

df.int.catch.summary <- df.int.catch %>%
  group_by(workerid, tested_on) %>%
  summarize(totalCorrect = sum(correct)) %>%
  ungroup() %>%
  spread(tested_on, totalCorrect) %>%
  rename(correct_rejection = `0`, 
         hit = `1`) %>%
  mutate(pass = ifelse(hit >= 4 & correct_rejection >= 4, 1, 0),
         totalCorrect = correct_rejection + hit)

df.int <- readData("interpretation/", interpretationDataLabel) %>%
  group_by(workerid) %>%
  mutate(normalizedResponse = (response - mean(response)) / sd(response))

df.int <- left_join(df.int, df.int.catch.summary %>%
                         select(workerid, totalCorrect, pass))

df.int.filtered <- df.int %>% filter(pass == 1) %>%
  mutate(response = as.numeric(response)) %>%
    mutate(property = gsub("&quotechar", "", property))

```

## Load model results

```{r}
#null.dists <- c("beta1_100", "beta1_1000", "delta")
semantics <- c("most", "some", "uncertain")
models <- c("literal", "pragmatic", "pragmatic_unlifted")
#modelName <- "pragmatic_unlifted"

m.samp <- data.frame()

for (sem in semantics){
  model.path <- paste("../models/results/genint/", sem, sep = "")
  if (sem == "uncertain") {
      for (modelName in models){
    
        
        model.prefix <-if (modelName == "literal"){
          "results-genint-L0-int6-prior3n200-3Components_uncertain-semantics_"
        } else if (modelName == "pragmatic_unlifted") {
          "results-genint-wCost-int6-prior3-3Components_pragmatic_unlifted-uncertain-"
        } else {
          "results-genint-wCost-int6-prior3-3Components_pragmatic-uncertain-"
        }
    
        #  FIXING PRIORS TO BE RAW EMPIRICAL DIISTRIBUUTIONS
        # model.prefix <-if (modelName == "literal"){
        #   "results-genint-wCost-int6-prior3-fixedPrior_literal-uncertain-"
        # } else if (modelName == "pragmatic_unlifted") {
        #   "results-genint-wCost-int6-prior3-fixedPrior_pragmatic_unlifted-uncertain-"
        # } else {
        #   "results-genint-wCost-int6-prior3-fixedPrior_pragmatic-uncertain-"
        # }
        
        n_samples <- if (modelName == "literal") { 500000 } else { 250000 }
        n_burn <- n_samples / 2
        lg <- if (modelName == "literal") { 150 } else { 75 }
    
        # n_samples <- if (modelName == "literal") { 1 } else { 10000 }
        # n_burn <- n_samples / 2
        # lg <- if (modelName == "pragmatic_unlifted") { 2 } else { 1 }
        
        model.files <- list.files(
          path = model.path,
          pattern = paste(model.prefix, format(n_samples, scientific = F), 
                          "_burn", n_burn, 
                      "_lag", lg, "_chain", sep = "")
          #paste(model.prefix, n_samples, "_burn", n_burn,
          #            "_lag", lg, "_chain", sep = "")
        )
        
        for (modfile in model.files){
          
          m.item <- read_csv(paste(model.path, modfile, sep = "/"))
    
          
          # FIXED PRIORR MODELLS JJUST USE THE "ELSE"  CODING SCHEME
          if (modelName == "literal"){
            m.item <- m.item %>%
              rename(component = property,
                     property = param,
                     parameter = category
                     )
          } else {
            m.item <- m.item %>% 
              rename(component = param,
                     parameter = category
                     )
         }
    
          m.samp <- bind_rows(
            m.samp,
            m.item %>% 
              mutate(
                src = modelName,
                semantics = sem,
                chain = match(modfile, model.files)
                )
          )
        }
      }
  } else {

    model.prefix <- paste(
     "results-genint-L0-int6-prior3n200-3Components_",sem,"-semantics_",
     sep = ""
    )
      

       n_samples <- 500000
        n_burn <- n_samples / 2
        lg <- 150

        model.files <- list.files(
          path = model.path,
          pattern = paste(model.prefix, format(n_samples, scientific = F), 
                          "_burn", n_burn, 
                      "_lag", lg, "_chain", sep = "")
          #paste(model.prefix, n_samples, "_burn", n_burn,
          #            "_lag", lg, "_chain", sep = "")
        )
        
        for (modfile in model.files){
          
          m.item <- read_csv(paste(model.path, modfile, sep = "/"))
    
          
          m.item <- m.item %>%
              rename(component = property,
                     property = param,
                     parameter = category)
          m.samp <- bind_rows(
            m.samp,
            m.item %>% 
              mutate(
                src = "literal",
                semantics = sem,
                chain = match(modfile, model.files)
                )
          )
        }
  }

}
m.samp <- m.samp %>%
  mutate(property = gsub("&quotechar", "", property))
#m.samp <- read_csv(paste(model.path,model.prefix,".csv", sep = ""))

```


### Speaker optimality parameter

```{r}
m.samp %>%
  #filter(type == "parameter") %>%
  filter(type %in% c("speakerOptimality","cost")) %>%
  ggplot(., aes( x = val, fill = factor(chain)))+
  geom_histogram(position = position_dodge())+
  facet_grid(type~src + semantics, scales = 'free')

# ggsave(paste("figs/", model.prefix, "speakerOptimality.pdf", sep = ""),
#        width = 4, height = 4)
```
```{r}
m.genint.params.l1 <- m.samp %>%
  filter(type %in% c("speakerOptimality","cost")) %>%
  group_by(type, src) %>%
  summarize(MAP = estimate_mode(val),
            cred_upper = hdi_upper(val),
            cred_lower = hdi_lower(val))

save(m.genint.params.l1, file = "../paper/cached_results/genint_L1_params.RData")
```



### Implied prevalence

```{r}
df.int.filtered.bs <-   df.int.filtered %>%
    #filter(property %in% levels(factor(m.samp$param))) %>%
    group_by(property) %>%
    tidyboot::tidyboot_mean(column = response)

md.impprev <- left_join(
  bind_rows(
   m.samp %>%
    #filter(parameter %in% c("prior", "posterior"), src != "literal") %>% #FIXEDPRIORRs
    filter(type == "prediction",  src != "literal") %>%
    #rename(component = property, property = param, parameter = category) %>%
    group_by(src, semantics, property, parameter) %>%
    summarize(model_MAP = estimate_mode(val),
            model_upper = hdi_upper(val),
            model_lower = hdi_lower(val)),
   m.samp %>%
    filter(src == "literal", parameter %in% c("prior", "posterior")) %>%
    group_by(src,semantics, property, parameter) %>%
    # summarize(model_MAP = val,
    #         model_upper = val,
    #         model_lower = val)
   summarize(model_MAP = estimate_mode(val),
      model_upper = hdi_upper(val),
      model_lower = hdi_lower(val))
  ),
  df.int.filtered.bs
)

# save(df.int.filtered, df.int.filtered.bs, md.impprev,
#      file = "../paper/cached_results/genInt_interpretation6_prior3_modelData2.RData")
```

```{r}
ggplot(md.impprev, aes( x = model_MAP, xmin = model_lower, xmax = model_upper, 
                        y = mean, ymin = ci_lower, ymax = ci_upper))+
  geom_abline(intercept = 0, slope = 1, lty = 2)+
  geom_point()+
  geom_errorbar(alpha = 0.3)+geom_errorbarh(alpha = 0.3)+
  facet_wrap(~src + parameter)+
  scale_x_continuous(limits = c(-0.01,1.01), breaks = c(0, 0.5, 1)) +
  scale_y_continuous(limits = c(-0.01,1.01), breaks = c(0, 0.5, 1)) +
  coord_fixed()

# ggsave(paste("figs/", model.prefix, "interpretationScatters.pdf", sep = ""),
#        width = 6, height = 4)
```
```{r}
md.impprev %>%
  filter(src %in% c("literal", "pragmatic_unlifted"), 
         parameter == "posterior", semantics == "uncertain") %>%
  select(src, property, model_MAP) %>%
  #unique() %>%
  spread(src, model_MAP) %>%
  ggplot(., aes( x = literal, y = pragmatic_unlifted))+
  geom_abline(intercept  = 0 , slope = 1)+
  geom_point()
```


### Error analysis

```{r}
md.impprev.genModels <- md.impprev %>%
  ungroup() %>%
  filter(src %in% c("literal", "pragmatic_unlifted"), 
         semantics == "uncertain",
         parameter == "posterior") %>%
  mutate(sqErr = (model_MAP - mean)^2) 

md.impprev.genModels %>%
  filter(src == "pragmatic_unlifted") %>% View()
```


```{r}
md.impprev %>%
  #filter(!is.na(mean)) %>%
  group_by(src, parameter) %>%
  summarize( mse  = mean((model_MAP-mean)^2),
             r2 = cor(model_MAP, mean)^2) %>% 
  kable()
```



### Prevalence prior parameters

#### Forward sample prevalence priors

Add iteration number back in.

```{r}
m.samp.iter <- m.samp %>%
  #filter(type %in% c("componentParameters")) %>%
  filter(parameter %in% c("weight", "alpha", "beta")) %>%
  # mutate(parameter = paste(type, param, property, category, sep = "_")) %>%
  # select(-type, -param, -property, -category) %>%
  mutate(parameter = paste(parameter, property, component, sep = "_")) %>%
  select(-property, -component) %>%
  group_by(parameter) %>%
  mutate(iteration = ave(parameter==parameter, parameter, FUN=cumsum)) %>%
  ungroup() %>%
#  separate(parameter, into = c("parameter", "property", "componentID", "componentParam"), sep= "_")
  separate(parameter, into = c("parameter", "property", "componentID"), 
           sep= "_")

m.rs.prior.parameters <- m.samp.iter %>% 
  #mutate(componentParam = paste(componentParam, "_", componentID, sep = "")) %>% select(-componentID) %>%
  mutate(componentParam = paste(parameter, "_", componentID, sep = "")) %>% select(-componentID, -parameter) %>%
  spread(componentParam, val) %>%
  rowwise() %>%
  mutate(component = LaplacesDemon::rcat(1, c(`weight_0`, `weight_1`, `weight_2`)) - 1,
         shape1_param = ifelse(component == 0, alpha_0, ifelse(component == 1, alpha_1, alpha_2)),
         shape2_param = ifelse(component == 0, beta_0, ifelse(component == 1, beta_1, beta_2)),
         prev = rbeta(shape1 = shape1_param, shape2 = shape2_param, n = 1))

```

##### Marginal distributions on prevalence

```{r gen-prevprior2-marginals, fig.width = 8, fig.height = 5}
md.prevpriors <- bind_rows(
  df.prior.filtered %>% 
    filter(property %in% levels(factor(m.rs.prior.parameters$property))) %>%
    select(property, response) %>%
    rename(prev = response) %>% 
    mutate(src = 'data'),
  m.rs.prior.parameters %>% 
    select(property, prev, src) %>%
    mutate(src = paste(src, semantics, sep = "_")) 
  )

ggplot(md.prevpriors , aes( x = prev, color = src))+
  geom_density(size = 1, aes( y = ..scaled.. ), adjust = 0.5)+
  facet_wrap( ~ property)+
  scale_color_solarized()+
  scale_x_continuous(limits = c(0,1), breaks = c(0, 0.5, 1)) +
  scale_y_continuous(limits = c(0,1), breaks = c(0, 0.5, 1)) +
  theme(strip.text.y = element_text(angle = 0))

# ggsave(paste("figs/", model.prefix, "prevPriorsPDFs.pdf", sep = ""),
#        width = 14, height = 8)
```

##### Cumulative Density Functions

```{r gen-prevprior2-cdf, fig.width = 8, fig.height = 5}
fig.prevprior.cdf.collapse <- ggplot(md.prevpriors, aes( x = prev, color = src))+
    stat_ecdf()+
    facet_wrap(~property)+
    #scale_color_solarized()+
    scale_x_continuous(limits = c(-0.01,1.01), breaks = c(0, 0.5, 1)) +
    scale_y_continuous(limits = c(-0.01,1.01), breaks = c(0, 0.5, 1)) +
    theme(strip.text.y = element_text(angle = 0))+
    coord_fixed()

ggsave(paste("joint_prevPriorsCDFs.pdf", sep = ""),
       width = 5.5, height = 3.5)

ggsave(paste("individual_prevPriorsCDFs.pdf", sep = ""),
       width = 14, height = 8)
```

```{r wip}
m.samp.iter.weight <- m.samp.iter %>%
  filter((componentParam == "weight") | (parameter == "numberOfComponents")) %>%
  mutate(componentID = paste("component", componentID, sep = "")) %>%
  spread(componentID, val)

m.samp.iter.param <- m.samp.iter %>%
  filter(componentParam %in% c("alpha", "beta")) %>%
  spread(componentParam, val)

# for (p in levels(factor(m.samp.iter$property))){
#   for (i in seq(1, n_samples){
#     
#   }
# }
# 
# m.samp.iter.weight.i <- m.samp.iter.weight %>% 
  filter(iteration == 10, property == 'develop phobias')

indices <- paste("component", 
                 seq(0, 
                     filter(m.samp.iter.weight.i, 
                            parameter == 'numberOfComponents')[[1, "component-99"]]), 
                 sep ="")

ps <- as.numeric(as.vector(
  filter(m.samp.iter.weight.i, 
         componentParam == 'weight')[1,indices]
  ))

componentId <- LaplacesDemon::rcat(1, ps)

m.samp.iter.param %>%
  filter(property == p, iteration == i, componentID == componentId) %>%
  mutate(prev = rbeta(shape1 = alpha, shape2 = beta, n = 1))

```


## Model comparison

```{r}
mll.results.path <- "../models/results/genint/marginal_likelihood/final_results/"
mll.results = list.files(
  path = mll.results.path,
  # pattern = paste(model.prefix, format(n_samples, scientific = F), 
  #                 "_burn", n_burn, 
  #             "_lag", lg, "_chain", sep = "")
)
extractMLLfromJSON <- function(fileName){
  name1 <- strsplit(fileName, "-")[[1]][4]
  name2 <- strsplit(fileName, "-")[[1]][5]
  rs <- jsonlite::fromJSON(paste(mll.results.path, fileName, sep = ""))[1]
  return(data.frame(name1=name1, name2=name2, mll=rs))
}

rs.mll <- bind_rows(lapply(mll.results, extractMLLfromJSON)) %>%
  mutate(name2 = ifelse(name1 == "steps2000","generic", name2))

rs.mll.formatted <- rs.mll %>%
  group_by(name1, name2) %>%
  summarize(mll = mean(mll)) %>%
  ungroup() %>%
  mutate(Model = ifelse(name2 == "most", '"Most"',
                  ifelse(name1 == "prior", "Prior", 
                 ifelse(name2 == "some", '"Some"',
                ifelse(name1 == "pragmatic_unlifted", 
                       "Pragmatic Generic",
                 ifelse(name2 == "generic", "Literal Generic", name1)))))) %>%
  filter(!Model == "pragmatic") %>%
  select(Model, mll)

save(rs.mll.formatted, file = "../paper/cached_results/genint_BF_results.RData")
```


## (not working) RWebPPL RSA/BDA Model

### RWebPPL model (not working)

rwebppl doesn't like returning supports with variable elements (this is because I'm inferring the number of components)

```{r}
rsa.bda.model <- '
var priorData = map(avoidEnds, data.prior)
var interpretationData = map(
  function(d){ return utils.closest( midBins.slice(1), d) }, 
  data.interpretation
)

// display(priorData)
// display(interpretationData)
var meaning = function(utt,state, theta) {
  return utt=="generic"? state > theta :
         true
}

var model = function(){

  var numberOfComponents = 3// poisson(1) + 1;

  var weights = normalize(repeat(numberOfComponents,
    function(){ return uniformDrift({a: 0, b: 1, width:0.2}) }
  ))

  var componentParameters = repeat(numberOfComponents,
   function(){
    return betaShape({
        g: uniformDrift({a: 0, b: 1, width: 0.2}),
        d: uniformDrift({a: 0, b: 100, width: 5})
      })
  })

	mapData({data: priorData}, function(d){
    var componentLogLikelihood = map2(function(w, params){
      Math.log(w) + Beta(params).score(d)
    }, weights, componentParameters)
    var scr = util.logsumexp(componentLogLikelihood)
    // console.log(scr)
		factor(scr)
	})

	var statePrior = Infer({model: function(){
    sample(DiscretizedBeta(componentParameters[discrete(weights)]))
	}});

	/// RSA model
	var listener0 = cache(function(utterance) {
	  Infer({model: function(){
	    var state = sample(statePrior), theta = sample(thetaPrior);
	    var m = meaning(utterance, state, theta)
	    condition(m)
	    return state
	 }})}, 10000)

   var interpretationPrediction = listener0("generic")

   mapData({data:interpretationData}, function(d){
     // display(d)
      var scr = interpretationPrediction.score(d)
      scr == -Infinity ? displayObj(d) : null
     // display(scr)
     // observe(interpretationPrediction, d)
   })

   // RECORD PARAMETERS AND PREDICTIVES
   // query.add(["numberOfComponents", -99, -99, -99], numberOfComponents)

   // foreach(_.range(numberOfComponents), function(i){
  //    query.add(["componentParameters", i, weights[i], componentParameters[i]["a"]], componentParameters[i]["b"]
     //)
   // })

  // query.add(["prediction", -99, -99, expectation(statePrior)], expectation(interpretationPrediction))

   var componentParams_obj = _.fromPairs(_.flatten(map(function(i){
   return [
      ["weight_"+ i, weights[i]],
      ["a_"+ i, componentParameters[i]["a"]],
      ["b_"+ i, componentParameters[i]["b"]]
    ]
   },_.range(numberOfComponents))))
  
  return extend({
    priorMean: expectation(statePrior), 
    posteriorMean: expectation(interpretationPrediction),
  }, componentParams_obj)

}
'
```

```{r}
all.properties <- unique(df.int.filtered$property)
n_samples <- 5000
n_burn <- n_samples / 2
wp.rs.predictives <- data.frame()
wp.rs.prior.parameters <- data.frame()

for (p in all.properties[1:10]){
  
  priorData <- filter(df.prior.filtered, property == p)$response
  interpretationData <- filter(df.int.filtered, property == p)$response

  dataToPass = list(prior = priorData, interpretation = interpretationData)
  
  wp.rs <- webppl(program_code = rsa.bda.model,
                packages = c("node_modules/utils"),
                data_var = "data", data = dataToPass,
                model_var = "model", 
                inference_opts = list(method = "MCMC",
                                      samples = n_samples,
                                      burn = n_burn,
                                      verbose = TRUE))
  

  wp.rs.predictives <- bind_rows(
    wp.rs.predictives,
    wp.rs %>% filter(Parameter %in% c("priorMean", "posteriorMean"))  %>%
      mutate(property = p)
  )
  
  wp.rs.prior.parameters <- bind_rows(
    wp.rs.prior.parameters,
    wp.rs %>% filter(!(Parameter %in% c("priorMean", "posteriorMean"))) %>%
      #separate(Parameter, sep = "_", into = c("parameter", "component")) %>%
      mutate(property = p) 
  )

  print(p)
}
```

#### Forward sample prevalence priors

```{r}
wp.rs.prior.parameters <- wp.rs.prior.parameters %>% 
  spread(Parameter, value) %>%
  rowwise() %>%
  mutate(component = LaplacesDemon::rcat(1, c(`weight_0`, `weight_1`, `weight_2`)) - 1,
         shape1_param = ifelse(component == 0, a_0, ifelse(component == 1, a_1, a_2)),
         shape2_param = ifelse(component == 0, b_0, ifelse(component == 1, b_1, b_2)),
         prev = rbeta(shape1 = shape1_param, shape2 = shape2_param, n = 1))
```

##### Marginal distributions on prevalence

```{r gen-prevprior-marginals, fig.width = 8, fig.height = 5}
md.prevpriors <- bind_rows(
  df.prior.filtered %>% 
    filter(property %in% levels(factor(wp.rs.prior.parameters$property))) %>%
    select(property, response) %>%
    rename(prev = response) %>% 
    mutate(src = 'data'),
  wp.rs.prior.parameters %>% 
    select(property, prev) %>%
    mutate(src = 'model') 
  )


ggplot(md.prevpriors , aes( x = prev, color = src))+
  geom_density(size = 1, aes( y = ..scaled.. ), adjust = 0.5)+
  facet_wrap( ~ property)+
  scale_color_solarized()+
  scale_x_continuous(limits = c(0,1), breaks = c(0, 0.5, 1)) +
  scale_y_continuous(limits = c(0,1), breaks = c(0, 0.5, 1)) +
  theme(strip.text.y = element_text(angle = 0))
```

##### Cumulative Density Functions

```{r gen-prevprior-cdf, fig.width = 8, fig.height = 5}
ggplot(md.prevpriors, aes( x = prev, color = src))+
    stat_ecdf()+
    facet_wrap(~property, nrow = 3)+
    scale_color_solarized()+
    scale_x_continuous(limits = c(-0.01,1.01), breaks = c(0, 0.5, 1)) +
    scale_y_continuous(limits = c(-0.01,1.01), breaks = c(0, 0.5, 1)) +
    theme(strip.text.y = element_text(angle = 0))
```

#### Implied prevalence

```{r}

md.impprev <- left_join(
  wp.rs.predictives %>%
    group_by(property, Parameter) %>%
    summarize(model_MAP = estimate_mode(value),
            model_upper = hdi_upper(value),
            model_lower = hdi_lower(value)),
  df.int.filtered %>%
    filter(property %in% levels(factor(wp.rs.predictives$property))) %>%
    group_by(property) %>%
    tidyboot::tidyboot_mean(column = response)
)

```

```{r}
ggplot(md.impprev, aes( x = model_MAP, xmin = model_lower, xmax = model_upper, 
                        y = mean, ymin = ci_lower, ymax = ci_upper))+
  geom_point()+
  geom_errorbar(alpha = 0.3)+geom_errorbarh(alpha = 0.3)+
  facet_wrap(~Parameter)+
  scale_x_continuous(limits = c(-0.01,1.01), breaks = c(0, 0.5, 1)) +
  scale_y_continuous(limits = c(-0.01,1.01), breaks = c(0, 0.5, 1)) +
  coord_fixed()
```






